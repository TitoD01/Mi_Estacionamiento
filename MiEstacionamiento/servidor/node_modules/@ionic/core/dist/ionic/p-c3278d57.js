/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
import{p as e}from"./p-1b8e1d03.js";import{MENU_BACK_BUTTON_PRIORITY as t}from"./p-185e427e.js";import{c as n}from"./p-63eb0acd.js";import{b as r}from"./p-3e8d7ed8.js";import{c as s}from"./p-97c65aa5.js";const a=e=>s().duration(e?400:300),o=e=>{let t,n;const o=e.width+8,i=s(),u=s();e.isEndSide?(t=o+"px",n="0px"):(t=-o+"px",n="0px"),i.addElement(e.menuInnerEl).fromTo("transform",`translateX(${t})`,`translateX(${n})`);const c="ios"===r(e),p=c?.2:.25;return u.addElement(e.backdropEl).fromTo("opacity",.01,p),a(c).addAnimation([i,u])},i=e=>{let t,n;const o=r(e),i=e.width;e.isEndSide?(t=-i+"px",n=i+"px"):(t=i+"px",n=-i+"px");const u=s().addElement(e.menuInnerEl).fromTo("transform",`translateX(${n})`,"translateX(0px)"),c=s().addElement(e.contentEl).fromTo("transform","translateX(0px)",`translateX(${t})`),p=s().addElement(e.backdropEl).fromTo("opacity",.01,.32);return a("ios"===o).addAnimation([u,c,p])},u=e=>{const t=r(e),n=e.width*(e.isEndSide?-1:1)+"px",o=s().addElement(e.contentEl).fromTo("transform","translateX(0px)",`translateX(${n})`);return a("ios"===t).addAnimation(o)},c=(()=>{const r=new Map,s=[],a=async(t,n=!1)=>{if(await l(),"start"===t||"end"===t){const r=s.filter((e=>e.side===t&&!e.disabled));if(r.length>=1)return r.length>1&&n&&e(`menuController queried for a menu on the "${t}" side, but ${r.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,r.map((e=>e.el))),r[0].el;const a=s.filter((e=>e.side===t));if(a.length>=1)return a.length>1&&n&&e(`menuController queried for a menu on the "${t}" side, but ${a.length} menus were found. The first menu reference will be used. If this is not the behavior you want then pass the ID of the menu instead of its side.`,a.map((e=>e.el))),a[0].el}else if(null!=t)return d((e=>e.menuId===t));return d((e=>!e.disabled))||(s.length>0?s[0].el:void 0)},c=async()=>(await l(),m()),p=(e,t)=>{r.set(e,t)},m=()=>d((e=>e._isOpen)),f=()=>s.some((e=>e.isAnimating)),d=e=>{const t=s.find(e);if(void 0!==t)return t.el},l=()=>Promise.all(Array.from(document.querySelectorAll("ion-menu")).map((e=>new Promise((t=>n(e,t))))));return p("reveal",u),p("push",i),p("overlay",o),"undefined"!=typeof document&&document.addEventListener("ionBackButton",(e=>{const n=m();n&&e.detail.register(t,(()=>n.close()))})),{registerAnimation:p,get:a,getMenus:async()=>(await l(),s.map((e=>e.el))),getOpen:c,isEnabled:async e=>{const t=await a(e);return!!t&&!t.disabled},swipeGesture:async(e,t)=>{const n=await a(t);return n&&(n.swipeGesture=e),n},isAnimating:async()=>(await l(),f()),isOpen:async e=>{if(null!=e){const t=await a(e);return void 0!==t&&t.isOpen()}return void 0!==await c()},enable:async(e,t)=>{const n=await a(t);return n&&(n.disabled=!e),n},toggle:async e=>{const t=await a(e,!0);return!!t&&t.toggle()},close:async e=>{const t=await(void 0!==e?a(e,!0):c());return void 0!==t&&t.close()},open:async e=>{const t=await a(e,!0);return!!t&&t.open()},_getOpenSync:m,_createAnimation:(e,t)=>{const n=r.get(e);if(!n)throw new Error("animation not registered");return n(t)},_register:e=>{s.indexOf(e)<0&&s.push(e)},_unregister:e=>{const t=s.indexOf(e);t>-1&&s.splice(t,1)},_setOpen:async(e,t,n)=>{if(f())return!1;if(t){const t=await c();t&&e.el!==t&&await t.setOpen(!1,!1)}return e._setOpen(t,n)}}})();export{c as m}